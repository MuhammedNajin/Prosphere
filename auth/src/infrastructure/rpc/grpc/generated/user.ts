// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v5.29.1
// source: user.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  type Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";

export const protobufPackage = "user";

/** Location message */
export interface Location {
  placeName: string;
  type: string;
  coordinates: number[];
}

/** User message */
export interface User {
  id: string;
  email: string;
  username: string;
  phone: string;
  role: string;
  profileImageKey: string;
  coverImageKey: string;
  resumeKeys: string[];
  createdAt: string;
  updatedAt: string;
}

/** Signin */
export interface SigninRequest {
  email: string;
  password: string;
}

export interface SigninResponse {
  accessToken: string;
  refreshToken: string;
  user: User | undefined;
}

/** Signup */
export interface SignupRequest {
  email: string;
  password: string;
  username: string;
  phone?: string | undefined;
  location?: Location | undefined;
  companyName?: string | undefined;
}

export interface SignupResponse {
  success: boolean;
  message: string;
}

/** Verify OTP */
export interface VerifyOtpRequest {
  email: string;
  otp: string;
}

export interface VerifyOtpResponse {
  accessToken: string;
  refreshToken: string;
  user: User | undefined;
}

/** Forgot Password */
export interface ForgotPasswordRequest {
  email: string;
}

export interface ForgotPasswordResponse {
  success: boolean;
  message: string;
}

/** Reset Password */
export interface ResetPasswordRequest {
  token: string;
  newPassword: string;
}

export interface ResetPasswordResponse {
  success: boolean;
  message: string;
}

/** Google Auth */
export interface GoogleAuthRequest {
  token: string;
}

export interface GoogleAuthResponse {
  accessToken?: string | undefined;
  refreshToken?: string | undefined;
  user?: User | undefined;
  profileComplete: boolean;
}

/** Google Auth Flow */
export interface GoogleAuthFlowRequest {
  email: string;
  phone: string;
  location: Location | undefined;
}

export interface GoogleAuthFlowResponse {
  accessToken: string;
  refreshToken: string;
  user: User | undefined;
}

/** Refresh Token */
export interface RefreshTokenRequest {
  refreshToken: string;
}

export interface RefreshTokenResponse {
  accessToken: string;
  refreshToken: string;
}

/** Change Password */
export interface ChangePasswordRequest {
  id: string;
  oldPassword: string;
  newPassword: string;
}

export interface ChangePasswordResponse {
  success: boolean;
  message: string;
}

function createBaseLocation(): Location {
  return { placeName: "", type: "", coordinates: [] };
}

export const Location: MessageFns<Location> = {
  encode(message: Location, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.placeName !== "") {
      writer.uint32(10).string(message.placeName);
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    writer.uint32(26).fork();
    for (const v of message.coordinates) {
      writer.double(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Location {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLocation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.placeName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 3: {
          if (tag === 25) {
            message.coordinates.push(reader.double());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.coordinates.push(reader.double());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Location {
    return {
      placeName: isSet(object.placeName) ? globalThis.String(object.placeName) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      coordinates: globalThis.Array.isArray(object?.coordinates)
        ? object.coordinates.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: Location): unknown {
    const obj: any = {};
    if (message.placeName !== "") {
      obj.placeName = message.placeName;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.coordinates?.length) {
      obj.coordinates = message.coordinates;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Location>, I>>(base?: I): Location {
    return Location.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Location>, I>>(object: I): Location {
    const message = createBaseLocation();
    message.placeName = object.placeName ?? "";
    message.type = object.type ?? "";
    message.coordinates = object.coordinates?.map((e) => e) || [];
    return message;
  },
};

function createBaseUser(): User {
  return {
    id: "",
    email: "",
    username: "",
    phone: "",
    role: "",
    profileImageKey: "",
    coverImageKey: "",
    resumeKeys: [],
    createdAt: "",
    updatedAt: "",
  };
}

export const User: MessageFns<User> = {
  encode(message: User, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.email !== "") {
      writer.uint32(18).string(message.email);
    }
    if (message.username !== "") {
      writer.uint32(26).string(message.username);
    }
    if (message.phone !== "") {
      writer.uint32(34).string(message.phone);
    }
    if (message.role !== "") {
      writer.uint32(42).string(message.role);
    }
    if (message.profileImageKey !== "") {
      writer.uint32(50).string(message.profileImageKey);
    }
    if (message.coverImageKey !== "") {
      writer.uint32(58).string(message.coverImageKey);
    }
    for (const v of message.resumeKeys) {
      writer.uint32(66).string(v!);
    }
    if (message.createdAt !== "") {
      writer.uint32(74).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(82).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.phone = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.role = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.profileImageKey = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.coverImageKey = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.resumeKeys.push(reader.string());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): User {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      phone: isSet(object.phone) ? globalThis.String(object.phone) : "",
      role: isSet(object.role) ? globalThis.String(object.role) : "",
      profileImageKey: isSet(object.profileImageKey) ? globalThis.String(object.profileImageKey) : "",
      coverImageKey: isSet(object.coverImageKey) ? globalThis.String(object.coverImageKey) : "",
      resumeKeys: globalThis.Array.isArray(object?.resumeKeys)
        ? object.resumeKeys.map((e: any) => globalThis.String(e))
        : [],
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
    };
  },

  toJSON(message: User): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.phone !== "") {
      obj.phone = message.phone;
    }
    if (message.role !== "") {
      obj.role = message.role;
    }
    if (message.profileImageKey !== "") {
      obj.profileImageKey = message.profileImageKey;
    }
    if (message.coverImageKey !== "") {
      obj.coverImageKey = message.coverImageKey;
    }
    if (message.resumeKeys?.length) {
      obj.resumeKeys = message.resumeKeys;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<User>, I>>(base?: I): User {
    return User.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<User>, I>>(object: I): User {
    const message = createBaseUser();
    message.id = object.id ?? "";
    message.email = object.email ?? "";
    message.username = object.username ?? "";
    message.phone = object.phone ?? "";
    message.role = object.role ?? "";
    message.profileImageKey = object.profileImageKey ?? "";
    message.coverImageKey = object.coverImageKey ?? "";
    message.resumeKeys = object.resumeKeys?.map((e) => e) || [];
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseSigninRequest(): SigninRequest {
  return { email: "", password: "" };
}

export const SigninRequest: MessageFns<SigninRequest> = {
  encode(message: SigninRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    if (message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SigninRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSigninRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SigninRequest {
    return {
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
    };
  },

  toJSON(message: SigninRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SigninRequest>, I>>(base?: I): SigninRequest {
    return SigninRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SigninRequest>, I>>(object: I): SigninRequest {
    const message = createBaseSigninRequest();
    message.email = object.email ?? "";
    message.password = object.password ?? "";
    return message;
  },
};

function createBaseSigninResponse(): SigninResponse {
  return { accessToken: "", refreshToken: "", user: undefined };
}

export const SigninResponse: MessageFns<SigninResponse> = {
  encode(message: SigninResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessToken !== "") {
      writer.uint32(10).string(message.accessToken);
    }
    if (message.refreshToken !== "") {
      writer.uint32(18).string(message.refreshToken);
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SigninResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSigninResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SigninResponse {
    return {
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "",
      refreshToken: isSet(object.refreshToken) ? globalThis.String(object.refreshToken) : "",
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
    };
  },

  toJSON(message: SigninResponse): unknown {
    const obj: any = {};
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.refreshToken !== "") {
      obj.refreshToken = message.refreshToken;
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SigninResponse>, I>>(base?: I): SigninResponse {
    return SigninResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SigninResponse>, I>>(object: I): SigninResponse {
    const message = createBaseSigninResponse();
    message.accessToken = object.accessToken ?? "";
    message.refreshToken = object.refreshToken ?? "";
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    return message;
  },
};

function createBaseSignupRequest(): SignupRequest {
  return { email: "", password: "", username: "", phone: undefined, location: undefined, companyName: undefined };
}

export const SignupRequest: MessageFns<SignupRequest> = {
  encode(message: SignupRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    if (message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    if (message.username !== "") {
      writer.uint32(26).string(message.username);
    }
    if (message.phone !== undefined) {
      writer.uint32(34).string(message.phone);
    }
    if (message.location !== undefined) {
      Location.encode(message.location, writer.uint32(42).fork()).join();
    }
    if (message.companyName !== undefined) {
      writer.uint32(50).string(message.companyName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignupRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.phone = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.location = Location.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.companyName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignupRequest {
    return {
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      phone: isSet(object.phone) ? globalThis.String(object.phone) : undefined,
      location: isSet(object.location) ? Location.fromJSON(object.location) : undefined,
      companyName: isSet(object.companyName) ? globalThis.String(object.companyName) : undefined,
    };
  },

  toJSON(message: SignupRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.phone !== undefined) {
      obj.phone = message.phone;
    }
    if (message.location !== undefined) {
      obj.location = Location.toJSON(message.location);
    }
    if (message.companyName !== undefined) {
      obj.companyName = message.companyName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SignupRequest>, I>>(base?: I): SignupRequest {
    return SignupRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignupRequest>, I>>(object: I): SignupRequest {
    const message = createBaseSignupRequest();
    message.email = object.email ?? "";
    message.password = object.password ?? "";
    message.username = object.username ?? "";
    message.phone = object.phone ?? undefined;
    message.location = (object.location !== undefined && object.location !== null)
      ? Location.fromPartial(object.location)
      : undefined;
    message.companyName = object.companyName ?? undefined;
    return message;
  },
};

function createBaseSignupResponse(): SignupResponse {
  return { success: false, message: "" };
}

export const SignupResponse: MessageFns<SignupResponse> = {
  encode(message: SignupResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignupResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignupResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignupResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: SignupResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SignupResponse>, I>>(base?: I): SignupResponse {
    return SignupResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignupResponse>, I>>(object: I): SignupResponse {
    const message = createBaseSignupResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseVerifyOtpRequest(): VerifyOtpRequest {
  return { email: "", otp: "" };
}

export const VerifyOtpRequest: MessageFns<VerifyOtpRequest> = {
  encode(message: VerifyOtpRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    if (message.otp !== "") {
      writer.uint32(18).string(message.otp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VerifyOtpRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifyOtpRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.otp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VerifyOtpRequest {
    return {
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      otp: isSet(object.otp) ? globalThis.String(object.otp) : "",
    };
  },

  toJSON(message: VerifyOtpRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.otp !== "") {
      obj.otp = message.otp;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VerifyOtpRequest>, I>>(base?: I): VerifyOtpRequest {
    return VerifyOtpRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VerifyOtpRequest>, I>>(object: I): VerifyOtpRequest {
    const message = createBaseVerifyOtpRequest();
    message.email = object.email ?? "";
    message.otp = object.otp ?? "";
    return message;
  },
};

function createBaseVerifyOtpResponse(): VerifyOtpResponse {
  return { accessToken: "", refreshToken: "", user: undefined };
}

export const VerifyOtpResponse: MessageFns<VerifyOtpResponse> = {
  encode(message: VerifyOtpResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessToken !== "") {
      writer.uint32(10).string(message.accessToken);
    }
    if (message.refreshToken !== "") {
      writer.uint32(18).string(message.refreshToken);
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VerifyOtpResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifyOtpResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VerifyOtpResponse {
    return {
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "",
      refreshToken: isSet(object.refreshToken) ? globalThis.String(object.refreshToken) : "",
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
    };
  },

  toJSON(message: VerifyOtpResponse): unknown {
    const obj: any = {};
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.refreshToken !== "") {
      obj.refreshToken = message.refreshToken;
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VerifyOtpResponse>, I>>(base?: I): VerifyOtpResponse {
    return VerifyOtpResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VerifyOtpResponse>, I>>(object: I): VerifyOtpResponse {
    const message = createBaseVerifyOtpResponse();
    message.accessToken = object.accessToken ?? "";
    message.refreshToken = object.refreshToken ?? "";
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    return message;
  },
};

function createBaseForgotPasswordRequest(): ForgotPasswordRequest {
  return { email: "" };
}

export const ForgotPasswordRequest: MessageFns<ForgotPasswordRequest> = {
  encode(message: ForgotPasswordRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ForgotPasswordRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForgotPasswordRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ForgotPasswordRequest {
    return { email: isSet(object.email) ? globalThis.String(object.email) : "" };
  },

  toJSON(message: ForgotPasswordRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ForgotPasswordRequest>, I>>(base?: I): ForgotPasswordRequest {
    return ForgotPasswordRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ForgotPasswordRequest>, I>>(object: I): ForgotPasswordRequest {
    const message = createBaseForgotPasswordRequest();
    message.email = object.email ?? "";
    return message;
  },
};

function createBaseForgotPasswordResponse(): ForgotPasswordResponse {
  return { success: false, message: "" };
}

export const ForgotPasswordResponse: MessageFns<ForgotPasswordResponse> = {
  encode(message: ForgotPasswordResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ForgotPasswordResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForgotPasswordResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ForgotPasswordResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: ForgotPasswordResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ForgotPasswordResponse>, I>>(base?: I): ForgotPasswordResponse {
    return ForgotPasswordResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ForgotPasswordResponse>, I>>(object: I): ForgotPasswordResponse {
    const message = createBaseForgotPasswordResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseResetPasswordRequest(): ResetPasswordRequest {
  return { token: "", newPassword: "" };
}

export const ResetPasswordRequest: MessageFns<ResetPasswordRequest> = {
  encode(message: ResetPasswordRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    if (message.newPassword !== "") {
      writer.uint32(18).string(message.newPassword);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResetPasswordRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResetPasswordRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.newPassword = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResetPasswordRequest {
    return {
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      newPassword: isSet(object.newPassword) ? globalThis.String(object.newPassword) : "",
    };
  },

  toJSON(message: ResetPasswordRequest): unknown {
    const obj: any = {};
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.newPassword !== "") {
      obj.newPassword = message.newPassword;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResetPasswordRequest>, I>>(base?: I): ResetPasswordRequest {
    return ResetPasswordRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResetPasswordRequest>, I>>(object: I): ResetPasswordRequest {
    const message = createBaseResetPasswordRequest();
    message.token = object.token ?? "";
    message.newPassword = object.newPassword ?? "";
    return message;
  },
};

function createBaseResetPasswordResponse(): ResetPasswordResponse {
  return { success: false, message: "" };
}

export const ResetPasswordResponse: MessageFns<ResetPasswordResponse> = {
  encode(message: ResetPasswordResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResetPasswordResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResetPasswordResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResetPasswordResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: ResetPasswordResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResetPasswordResponse>, I>>(base?: I): ResetPasswordResponse {
    return ResetPasswordResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResetPasswordResponse>, I>>(object: I): ResetPasswordResponse {
    const message = createBaseResetPasswordResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseGoogleAuthRequest(): GoogleAuthRequest {
  return { token: "" };
}

export const GoogleAuthRequest: MessageFns<GoogleAuthRequest> = {
  encode(message: GoogleAuthRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GoogleAuthRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGoogleAuthRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GoogleAuthRequest {
    return { token: isSet(object.token) ? globalThis.String(object.token) : "" };
  },

  toJSON(message: GoogleAuthRequest): unknown {
    const obj: any = {};
    if (message.token !== "") {
      obj.token = message.token;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GoogleAuthRequest>, I>>(base?: I): GoogleAuthRequest {
    return GoogleAuthRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GoogleAuthRequest>, I>>(object: I): GoogleAuthRequest {
    const message = createBaseGoogleAuthRequest();
    message.token = object.token ?? "";
    return message;
  },
};

function createBaseGoogleAuthResponse(): GoogleAuthResponse {
  return { accessToken: undefined, refreshToken: undefined, user: undefined, profileComplete: false };
}

export const GoogleAuthResponse: MessageFns<GoogleAuthResponse> = {
  encode(message: GoogleAuthResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessToken !== undefined) {
      writer.uint32(10).string(message.accessToken);
    }
    if (message.refreshToken !== undefined) {
      writer.uint32(18).string(message.refreshToken);
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(26).fork()).join();
    }
    if (message.profileComplete !== false) {
      writer.uint32(32).bool(message.profileComplete);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GoogleAuthResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGoogleAuthResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.profileComplete = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GoogleAuthResponse {
    return {
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : undefined,
      refreshToken: isSet(object.refreshToken) ? globalThis.String(object.refreshToken) : undefined,
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      profileComplete: isSet(object.profileComplete) ? globalThis.Boolean(object.profileComplete) : false,
    };
  },

  toJSON(message: GoogleAuthResponse): unknown {
    const obj: any = {};
    if (message.accessToken !== undefined) {
      obj.accessToken = message.accessToken;
    }
    if (message.refreshToken !== undefined) {
      obj.refreshToken = message.refreshToken;
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.profileComplete !== false) {
      obj.profileComplete = message.profileComplete;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GoogleAuthResponse>, I>>(base?: I): GoogleAuthResponse {
    return GoogleAuthResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GoogleAuthResponse>, I>>(object: I): GoogleAuthResponse {
    const message = createBaseGoogleAuthResponse();
    message.accessToken = object.accessToken ?? undefined;
    message.refreshToken = object.refreshToken ?? undefined;
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.profileComplete = object.profileComplete ?? false;
    return message;
  },
};

function createBaseGoogleAuthFlowRequest(): GoogleAuthFlowRequest {
  return { email: "", phone: "", location: undefined };
}

export const GoogleAuthFlowRequest: MessageFns<GoogleAuthFlowRequest> = {
  encode(message: GoogleAuthFlowRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    if (message.phone !== "") {
      writer.uint32(26).string(message.phone);
    }
    if (message.location !== undefined) {
      Location.encode(message.location, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GoogleAuthFlowRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGoogleAuthFlowRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.phone = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.location = Location.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GoogleAuthFlowRequest {
    return {
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      phone: isSet(object.phone) ? globalThis.String(object.phone) : "",
      location: isSet(object.location) ? Location.fromJSON(object.location) : undefined,
    };
  },

  toJSON(message: GoogleAuthFlowRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.phone !== "") {
      obj.phone = message.phone;
    }
    if (message.location !== undefined) {
      obj.location = Location.toJSON(message.location);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GoogleAuthFlowRequest>, I>>(base?: I): GoogleAuthFlowRequest {
    return GoogleAuthFlowRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GoogleAuthFlowRequest>, I>>(object: I): GoogleAuthFlowRequest {
    const message = createBaseGoogleAuthFlowRequest();
    message.email = object.email ?? "";
    message.phone = object.phone ?? "";
    message.location = (object.location !== undefined && object.location !== null)
      ? Location.fromPartial(object.location)
      : undefined;
    return message;
  },
};

function createBaseGoogleAuthFlowResponse(): GoogleAuthFlowResponse {
  return { accessToken: "", refreshToken: "", user: undefined };
}

export const GoogleAuthFlowResponse: MessageFns<GoogleAuthFlowResponse> = {
  encode(message: GoogleAuthFlowResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessToken !== "") {
      writer.uint32(10).string(message.accessToken);
    }
    if (message.refreshToken !== "") {
      writer.uint32(18).string(message.refreshToken);
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GoogleAuthFlowResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGoogleAuthFlowResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GoogleAuthFlowResponse {
    return {
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "",
      refreshToken: isSet(object.refreshToken) ? globalThis.String(object.refreshToken) : "",
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
    };
  },

  toJSON(message: GoogleAuthFlowResponse): unknown {
    const obj: any = {};
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.refreshToken !== "") {
      obj.refreshToken = message.refreshToken;
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GoogleAuthFlowResponse>, I>>(base?: I): GoogleAuthFlowResponse {
    return GoogleAuthFlowResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GoogleAuthFlowResponse>, I>>(object: I): GoogleAuthFlowResponse {
    const message = createBaseGoogleAuthFlowResponse();
    message.accessToken = object.accessToken ?? "";
    message.refreshToken = object.refreshToken ?? "";
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    return message;
  },
};

function createBaseRefreshTokenRequest(): RefreshTokenRequest {
  return { refreshToken: "" };
}

export const RefreshTokenRequest: MessageFns<RefreshTokenRequest> = {
  encode(message: RefreshTokenRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.refreshToken !== "") {
      writer.uint32(10).string(message.refreshToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RefreshTokenRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefreshTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RefreshTokenRequest {
    return { refreshToken: isSet(object.refreshToken) ? globalThis.String(object.refreshToken) : "" };
  },

  toJSON(message: RefreshTokenRequest): unknown {
    const obj: any = {};
    if (message.refreshToken !== "") {
      obj.refreshToken = message.refreshToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RefreshTokenRequest>, I>>(base?: I): RefreshTokenRequest {
    return RefreshTokenRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RefreshTokenRequest>, I>>(object: I): RefreshTokenRequest {
    const message = createBaseRefreshTokenRequest();
    message.refreshToken = object.refreshToken ?? "";
    return message;
  },
};

function createBaseRefreshTokenResponse(): RefreshTokenResponse {
  return { accessToken: "", refreshToken: "" };
}

export const RefreshTokenResponse: MessageFns<RefreshTokenResponse> = {
  encode(message: RefreshTokenResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessToken !== "") {
      writer.uint32(10).string(message.accessToken);
    }
    if (message.refreshToken !== "") {
      writer.uint32(18).string(message.refreshToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RefreshTokenResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefreshTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RefreshTokenResponse {
    return {
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "",
      refreshToken: isSet(object.refreshToken) ? globalThis.String(object.refreshToken) : "",
    };
  },

  toJSON(message: RefreshTokenResponse): unknown {
    const obj: any = {};
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.refreshToken !== "") {
      obj.refreshToken = message.refreshToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RefreshTokenResponse>, I>>(base?: I): RefreshTokenResponse {
    return RefreshTokenResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RefreshTokenResponse>, I>>(object: I): RefreshTokenResponse {
    const message = createBaseRefreshTokenResponse();
    message.accessToken = object.accessToken ?? "";
    message.refreshToken = object.refreshToken ?? "";
    return message;
  },
};

function createBaseChangePasswordRequest(): ChangePasswordRequest {
  return { id: "", oldPassword: "", newPassword: "" };
}

export const ChangePasswordRequest: MessageFns<ChangePasswordRequest> = {
  encode(message: ChangePasswordRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.oldPassword !== "") {
      writer.uint32(18).string(message.oldPassword);
    }
    if (message.newPassword !== "") {
      writer.uint32(26).string(message.newPassword);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChangePasswordRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangePasswordRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.oldPassword = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.newPassword = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChangePasswordRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      oldPassword: isSet(object.oldPassword) ? globalThis.String(object.oldPassword) : "",
      newPassword: isSet(object.newPassword) ? globalThis.String(object.newPassword) : "",
    };
  },

  toJSON(message: ChangePasswordRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.oldPassword !== "") {
      obj.oldPassword = message.oldPassword;
    }
    if (message.newPassword !== "") {
      obj.newPassword = message.newPassword;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChangePasswordRequest>, I>>(base?: I): ChangePasswordRequest {
    return ChangePasswordRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChangePasswordRequest>, I>>(object: I): ChangePasswordRequest {
    const message = createBaseChangePasswordRequest();
    message.id = object.id ?? "";
    message.oldPassword = object.oldPassword ?? "";
    message.newPassword = object.newPassword ?? "";
    return message;
  },
};

function createBaseChangePasswordResponse(): ChangePasswordResponse {
  return { success: false, message: "" };
}

export const ChangePasswordResponse: MessageFns<ChangePasswordResponse> = {
  encode(message: ChangePasswordResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChangePasswordResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangePasswordResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChangePasswordResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: ChangePasswordResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChangePasswordResponse>, I>>(base?: I): ChangePasswordResponse {
    return ChangePasswordResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChangePasswordResponse>, I>>(object: I): ChangePasswordResponse {
    const message = createBaseChangePasswordResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

export type AuthServiceService = typeof AuthServiceService;
export const AuthServiceService = {
  signin: {
    path: "/user.AuthService/Signin",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SigninRequest): Buffer => Buffer.from(SigninRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): SigninRequest => SigninRequest.decode(value),
    responseSerialize: (value: SigninResponse): Buffer => Buffer.from(SigninResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SigninResponse => SigninResponse.decode(value),
  },
  signup: {
    path: "/user.AuthService/Signup",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SignupRequest): Buffer => Buffer.from(SignupRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): SignupRequest => SignupRequest.decode(value),
    responseSerialize: (value: SignupResponse): Buffer => Buffer.from(SignupResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SignupResponse => SignupResponse.decode(value),
  },
  verifyOtp: {
    path: "/user.AuthService/VerifyOtp",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: VerifyOtpRequest): Buffer => Buffer.from(VerifyOtpRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): VerifyOtpRequest => VerifyOtpRequest.decode(value),
    responseSerialize: (value: VerifyOtpResponse): Buffer => Buffer.from(VerifyOtpResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): VerifyOtpResponse => VerifyOtpResponse.decode(value),
  },
  forgotPassword: {
    path: "/user.AuthService/ForgotPassword",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ForgotPasswordRequest): Buffer =>
      Buffer.from(ForgotPasswordRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ForgotPasswordRequest => ForgotPasswordRequest.decode(value),
    responseSerialize: (value: ForgotPasswordResponse): Buffer =>
      Buffer.from(ForgotPasswordResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ForgotPasswordResponse => ForgotPasswordResponse.decode(value),
  },
  resetPassword: {
    path: "/user.AuthService/ResetPassword",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ResetPasswordRequest): Buffer => Buffer.from(ResetPasswordRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ResetPasswordRequest => ResetPasswordRequest.decode(value),
    responseSerialize: (value: ResetPasswordResponse): Buffer =>
      Buffer.from(ResetPasswordResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ResetPasswordResponse => ResetPasswordResponse.decode(value),
  },
  googleAuth: {
    path: "/user.AuthService/GoogleAuth",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GoogleAuthRequest): Buffer => Buffer.from(GoogleAuthRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GoogleAuthRequest => GoogleAuthRequest.decode(value),
    responseSerialize: (value: GoogleAuthResponse): Buffer => Buffer.from(GoogleAuthResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GoogleAuthResponse => GoogleAuthResponse.decode(value),
  },
  googleAuthFlow: {
    path: "/user.AuthService/GoogleAuthFlow",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GoogleAuthFlowRequest): Buffer =>
      Buffer.from(GoogleAuthFlowRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GoogleAuthFlowRequest => GoogleAuthFlowRequest.decode(value),
    responseSerialize: (value: GoogleAuthFlowResponse): Buffer =>
      Buffer.from(GoogleAuthFlowResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GoogleAuthFlowResponse => GoogleAuthFlowResponse.decode(value),
  },
  refreshToken: {
    path: "/user.AuthService/RefreshToken",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RefreshTokenRequest): Buffer => Buffer.from(RefreshTokenRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): RefreshTokenRequest => RefreshTokenRequest.decode(value),
    responseSerialize: (value: RefreshTokenResponse): Buffer =>
      Buffer.from(RefreshTokenResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RefreshTokenResponse => RefreshTokenResponse.decode(value),
  },
  changePassword: {
    path: "/user.AuthService/ChangePassword",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ChangePasswordRequest): Buffer =>
      Buffer.from(ChangePasswordRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ChangePasswordRequest => ChangePasswordRequest.decode(value),
    responseSerialize: (value: ChangePasswordResponse): Buffer =>
      Buffer.from(ChangePasswordResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ChangePasswordResponse => ChangePasswordResponse.decode(value),
  },
} as const;

export interface AuthServiceServer extends UntypedServiceImplementation {
  signin: handleUnaryCall<SigninRequest, SigninResponse>;
  signup: handleUnaryCall<SignupRequest, SignupResponse>;
  verifyOtp: handleUnaryCall<VerifyOtpRequest, VerifyOtpResponse>;
  forgotPassword: handleUnaryCall<ForgotPasswordRequest, ForgotPasswordResponse>;
  resetPassword: handleUnaryCall<ResetPasswordRequest, ResetPasswordResponse>;
  googleAuth: handleUnaryCall<GoogleAuthRequest, GoogleAuthResponse>;
  googleAuthFlow: handleUnaryCall<GoogleAuthFlowRequest, GoogleAuthFlowResponse>;
  refreshToken: handleUnaryCall<RefreshTokenRequest, RefreshTokenResponse>;
  changePassword: handleUnaryCall<ChangePasswordRequest, ChangePasswordResponse>;
}

export interface AuthServiceClient extends Client {
  signin(
    request: SigninRequest,
    callback: (error: ServiceError | null, response: SigninResponse) => void,
  ): ClientUnaryCall;
  signin(
    request: SigninRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SigninResponse) => void,
  ): ClientUnaryCall;
  signin(
    request: SigninRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SigninResponse) => void,
  ): ClientUnaryCall;
  signup(
    request: SignupRequest,
    callback: (error: ServiceError | null, response: SignupResponse) => void,
  ): ClientUnaryCall;
  signup(
    request: SignupRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SignupResponse) => void,
  ): ClientUnaryCall;
  signup(
    request: SignupRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SignupResponse) => void,
  ): ClientUnaryCall;
  verifyOtp(
    request: VerifyOtpRequest,
    callback: (error: ServiceError | null, response: VerifyOtpResponse) => void,
  ): ClientUnaryCall;
  verifyOtp(
    request: VerifyOtpRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: VerifyOtpResponse) => void,
  ): ClientUnaryCall;
  verifyOtp(
    request: VerifyOtpRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: VerifyOtpResponse) => void,
  ): ClientUnaryCall;
  forgotPassword(
    request: ForgotPasswordRequest,
    callback: (error: ServiceError | null, response: ForgotPasswordResponse) => void,
  ): ClientUnaryCall;
  forgotPassword(
    request: ForgotPasswordRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ForgotPasswordResponse) => void,
  ): ClientUnaryCall;
  forgotPassword(
    request: ForgotPasswordRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ForgotPasswordResponse) => void,
  ): ClientUnaryCall;
  resetPassword(
    request: ResetPasswordRequest,
    callback: (error: ServiceError | null, response: ResetPasswordResponse) => void,
  ): ClientUnaryCall;
  resetPassword(
    request: ResetPasswordRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ResetPasswordResponse) => void,
  ): ClientUnaryCall;
  resetPassword(
    request: ResetPasswordRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ResetPasswordResponse) => void,
  ): ClientUnaryCall;
  googleAuth(
    request: GoogleAuthRequest,
    callback: (error: ServiceError | null, response: GoogleAuthResponse) => void,
  ): ClientUnaryCall;
  googleAuth(
    request: GoogleAuthRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GoogleAuthResponse) => void,
  ): ClientUnaryCall;
  googleAuth(
    request: GoogleAuthRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GoogleAuthResponse) => void,
  ): ClientUnaryCall;
  googleAuthFlow(
    request: GoogleAuthFlowRequest,
    callback: (error: ServiceError | null, response: GoogleAuthFlowResponse) => void,
  ): ClientUnaryCall;
  googleAuthFlow(
    request: GoogleAuthFlowRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GoogleAuthFlowResponse) => void,
  ): ClientUnaryCall;
  googleAuthFlow(
    request: GoogleAuthFlowRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GoogleAuthFlowResponse) => void,
  ): ClientUnaryCall;
  refreshToken(
    request: RefreshTokenRequest,
    callback: (error: ServiceError | null, response: RefreshTokenResponse) => void,
  ): ClientUnaryCall;
  refreshToken(
    request: RefreshTokenRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: RefreshTokenResponse) => void,
  ): ClientUnaryCall;
  refreshToken(
    request: RefreshTokenRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: RefreshTokenResponse) => void,
  ): ClientUnaryCall;
  changePassword(
    request: ChangePasswordRequest,
    callback: (error: ServiceError | null, response: ChangePasswordResponse) => void,
  ): ClientUnaryCall;
  changePassword(
    request: ChangePasswordRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ChangePasswordResponse) => void,
  ): ClientUnaryCall;
  changePassword(
    request: ChangePasswordRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ChangePasswordResponse) => void,
  ): ClientUnaryCall;
}

export const AuthServiceClient = makeGenericClientConstructor(AuthServiceService, "user.AuthService") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): AuthServiceClient;
  service: typeof AuthServiceService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
